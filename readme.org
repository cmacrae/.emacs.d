* About
  This is my literate configuration for [[https://www.gnu.org/software/emacs/][Emacs]].
  This document includes a collection of configuration snippets to express how I personally like to use Emacs, each accompanied by some reasoning.
  I think it's important to include reasoning for each part so I can understand /why/ I use it. Plus the added benefit of others being able to peruse and borrow parts, just as I have from others.

  The combination of literacy and functionality is achieved using the amazing [[http://orgmode.org/][org-mode]], with [[http://orgmode.org/worg/org-contrib/babel/][org-babel]].

  Throughout this document, you'll notice heavy use of the brilliant [[https://github.com/jwiegley/use-package][use-package]].
  For anyone who hasn't tried out ~use-package~; I emplore you to do so - it truly makes managing your configuration an absolute joy.

* Configuration
** General
*** Global =:ensure= for use-package statements
    =use-package= has an =:ensure= keyword which dictates whether packages are installed or not.
    As most of my =use-package= configurations are for external packages, I set this to always ensure.
    Then, in cases where I don't want this to be true, I simply set =:ensure nil=
    #+BEGIN_SRC emacs-lisp
    (setq use-package-always-ensure t)
    #+END_SRC

*** A few Darwin specific configurations
    To make Emacs play a little nicer with window management, enable menu-bar-mode.
    Also, set the frame's dimensions based on pixels - this makes Emacs play nicer with tiling
    window managers, where no title bar is displayed.
    #+BEGIN_SRC emacs-lisp
    (cond
      ((string-equal system-type "darwin")
        (setq mac-option-modifier 'meta)
        (menu-bar-mode t)
        (setq frame-resize-pixelwise t)))
    #+END_SRC

*** Deactivation of functionality I don't tend to use
    - Backup files
    - Autosaving
    - Start-up message
    - Audible bell
    - Toolbar, tooltip, scrollbar, blinking cursor
    #+BEGIN_SRC emacs-lisp
    (setq make-backup-files       nil
          auto-save-default       nil
          inhibit-startup-message t
          ring-bell-function      'ignore)
    (dolist (mode
      '(tool-bar-mode
        tooltip-mode
        scroll-bar-mode
        blink-cursor-mode))
      (funcall mode 0))
    #+END_SRC

*** Discard customizations
    Emacs has a comprehensive customization system that allows configuration changes interactively.
    Personally, I opt to ensure all the configuration I use for my environment is declarative.
    As such, the following configuration sets the ~custom-file~ to be a random temporary file created each time Emacs starts.
    This means any customizations made interactively are discarded entirely.
    #+BEGIN_SRC emacs-lisp
    (setq custom-file (make-temp-file ""))
    #+END_SRC

*** Just use 'y' or 'n' instead of 'yes' or 'no'
    You'll find =yes-or-no= prompts coming up in Emacs a lot.
    I'd much rather just type =y= or =n= than =yes= or =no= every time...
    #+BEGIN_SRC emacs-lisp
    (fset 'yes-or-no-p 'y-or-n-p)
    #+END_SRC

*** Confirm quit
    This adds a confirmation prompt when quitting Emacs - because I'm only human.
    #+BEGIN_SRC emacs-lisp
    (setq confirm-kill-emacs 'yes-or-no-p)
    #+END_SRC

*** Set the scratch buffer string
    Set the scratch buffer's initial contents to include a comment with a timestamp of creation.
    Not really all that useful, but cleaner than the default comment, and I like having something there.
    #+BEGIN_SRC emacs-lisp
    (setq initial-scratch-message (format ";; Scratch buffer - started on %s\n\n" (current-time-string)))
    #+END_SRC

*** Use M-3 to insert an octothorp
    I'm usually on a British keyboard, so when doing =M-3=: insert an octothorp, not a GBP sign
    #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "M-3") '(lambda () (interactive) (insert "#")))
    #+END_SRC

*** Configure FlySpell to use aspell
    I use =aspell=, so this simply sets [[https://www.emacswiki.org/emacs/FlySpell][Flyspell]] to use it and passes a couple extra arguments
    #+BEGIN_SRC emacs-lisp
    (setq ispell-program-name "aspell")
    (setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_GB"))
    #+END_SRC

*** Calendar/Diary
    Set the start of the week for the calendar to be Monday.
    Sort entries when viewing diary items.
    #+BEGIN_SRC emacs-lisp
    (setq calendar-week-start-day 1)
    (setq diary-file "~/org/diary")
    (add-hook 'diary-list-entries-hook 'diary-sort-entries t)
    #+END_SRC

*** IRC
    Emacs comes with a great builtin IRC client: ERC.
    These are some general settings that're all pretty self explanatory: hide particular activity, autojoin channels for some servers.
    For convenience, I've also defined a =erc-conn= function for my usual connection parameters.
    #+begin_src emacs-lisp
    (use-package erc
      :ensure nil
      :custom
      (erc-server "irc.freenode.net" )
      (erc-nick "cmacrae")
      (erc-hide-list '("PART" "QUIT" "JOIN"))
      (erc-autojoin-channels-alist '(("freenode.net"
        "#lobsters"
        "#nixos"
        "#nix-darwin")))
      :config
      (defun cm/erc-conn ()
        (interactive)
        (erc-tls :server "irc.freenode.net" :port 6697 :nick "cmacrae")))
    #+end_src

** Meta Configurations
   This section includes the use of any "meta" collection of Emacs configurations provided by others.
   I'm using [[https://github.com/rougier/nano-emacs/issues/37][rougier/nano-emacs]] as a base. The configuration is shaped around principles that I agree with.
   #+BEGIN_SRC emacs-lisp
   (use-package nano-emacs
     :straight (:host github :repo "rougier/nano-emacs")
     :init
     (require 'nano-base-colors)
     (require 'nano-colors)
     (require 'nano-faces)
     (require 'nano-theme)
     (require 'nano-theme-dark)
     (require 'nano-theme-light)
     (require 'nano-modeline)
     (require 'nano-writer)
     ;; Seems there's a bug with this: Wrong type argument: char-table-p, nil
     ;; Returned from this in nano-layout.el
     ;;
     ;; (defface fallback '((t :family "Fira Code"
     ;;                        :inherit 'nano-face-faded)) "Fallback")
     ;; (set-display-table-slot standard-display-table 'truncation
     ;;                         (make-glyph-code ?… 'fallback))
     ;; (set-display-table-slot standard-display-table 'wrap
     ;;                          (make-glyph-code ?↩ 'fallback))
     ;; (require 'nano-layout)

     :hook
     (after-init . nano-faces)
     (after-init . nano-theme))
   #+END_SRC

** Packages
*** Ivy|Counsel|Swiper
    Absolutely brilliant interactive interface and completion frameworks.
    These packages improve the Emacs experience so much.
    As you can see from the =:bind= sections, I use these to replace some of the most used actions.

**** Ivy
    - Suppress count visibility for =ivy-read=
    - Set initial chars for certain inputs
    - Display the candidate menu at the current point position with =ivy-posframe=

    #+BEGIN_SRC emacs-lisp
    (use-package ivy
      :hook (after-init . ivy-mode)
      :bind
      ("C-s"     . swiper)
      ("M-x"     . counsel-M-x)
      ("C-x C-f" . counsel-find-file)
      
      :custom
      (ivy-height 4)
      (ivy-count-format "")
      (ivy-use-virtual-buffers t)
      (enable-recursive-minibuffers t)
      (ivy-initial-inputs-alist: '((counsel-minor            . "^+" )
                                   (counsel-package          . "^+" )
                                   (counsel-org-capture      . "^"  )
                                   (counsel-M-x              . "^"  )
                                   (counsel-describe-symbol  . "^"  )
                                   (org-refile               . ""   ) 
                                   (org-agenda-refile        . ""   )
                                   (org-capture-refile       . ""   )
                                   (Man-completion-table     . "^"  )
                                   (woman                    . "^"  ))))

    (use-package ivy-posframe
      :after ivy
      :hook (ivy-mode . ivy-posframe-mode)
      :custom
      (ivy-posframe-border-width 1)
      (ivy-posframe-parameters '((left-fringe . 8) (right-fringe . 8))
                                (swiper . nil)))
   #+END_SRC

**** Counsel
     - Set a prettier candidate delimiter for killring
     - Bind common functions
     - Bind common org functions
     - Ensure `smex` is installed for better candidate matching
    #+begin_src emacs-lisp
    (use-package counsel
      :custom
      (counsel-yank-pop-separator (concat "\n\n"
          (concat (apply 'concat (make-list 50 "---")) "\n")))
        
      :bind
      (("M-y"   . counsel-yank-pop)
       ("C-h f" . counsel-describe-function)
       ("C-h v" . counsel-describe-variable)

       :map org-mode-map
       ("C-c  C-j" . counsel-org-goto)
       ("C-c  C-q" . counsel-org-tag))

      :config
      (use-package smex :ensure t))
    #+end_src

*** Evil
    Vim emulation in Emacs. Because: yes, you can have the best of both worlds!

    Below you'll find various extensions to my Evil layer that generally improve the quality of life.
    #+BEGIN_SRC emacs-lisp
    (use-package evil
      :init (setq evil-want-C-u-scroll t)
      :hook (after-init . evil-mode))
    #+END_SRC

*** Projectile
    Project management based on version control repositories.
    Absolutely essential package for me. This makes hopping around and between various projects really easy.
    Not only that, but it allows project-wide actions. Like killing all buffers for a project, performing a project-wide find-and-replace, or a grep, etc.

    Some configuration I use:
    - Setting the completion system to =ivy=
    - Further integration of Counsel with Projectile than what's provided natively
    #+BEGIN_SRC emacs-lisp
    (use-package projectile
      :hook
      (after-init . projectile-global-mode)
      :custom
      (projectile-completion-system 'ivy))

    (use-package counsel-projectile
      :after projectile
      :hook
      (projectile-global-mode . counsel-projectile-mode)
      :bind
      ("C-c p s r" . counsel-projectile-rg))
    #+END_SRC

*** Magit
    The one true Git porcelain!
    Truely a joy to use - it surfaces the power of Git in such a fluent manner.
    Anyone using Git and Emacs *needs* Magit in their life!
    #+BEGIN_SRC emacs-lisp
    (use-package magit
      :bind ("C-c m" . magit-status)
      :config
      (use-package evil-magit :ensure t))
    #+END_SRC

*** Flycheck
    Have Flycheck turned on for everything - checking stuff is always good!
    And for convenience, add a ~posframe~.
    #+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :hook (after-init . global-flycheck-mode))
 
    (use-package flycheck-posframe
      :after flycheck
      :hook (flycheck-mode . flycheck-posframe-mode))
    #+END_SRC

*** Company
   Slick auto-complete framework
   #+BEGIN_SRC emacs-lisp
   (use-package company
     :hook (after-init . global-company-mode))
   #+END_SRC
*** hydra
    Great package to tie tangible actions together into convenient keybinding landscapes.
    Here, you'll find some "general" hydras - other hydras that are centric around packages will be found with that package's configuration.
  
    General hydras:
    - Zoom: increase/decrease current buffer text size
    - Transpose: transpose various constructs of text
    - Toggle mode: turn frequently "toggled" modes on and off
  
    Enhancement packages:
    - =hydra-posframe=: use =posframe= to display hydra buffers at custom positions
    #+begin_src emacs-lisp
    (use-package hydra
      :bind
      ("C-c z" . hydra-zoom/body)
      ("C-c T" . hydra-transpose/body)
      ("C-c M" . hydra-toggle-mode/body)
  
      :config
      ;; Zoom
      (defhydra hydra-zoom ()
        "Zoom"
        ("i" text-scale-increase "In")
        ("o" text-scale-decrease "Out")
        ("q" nil "Quit" :color blue))
  
      ;; Transpose
      (defhydra hydra-transpose (:color red)
        "Transpose"
        ("c" transpose-chars "Characters")
        ("w" transpose-words "Words")
        ("l" transpose-lines "Lines")
        ("s" transpose-sentences "Sentences")
        ("p" transpose-paragraphs "Paragraphs")
        ("q" nil "Quit" :color blue)))

    ;; TODO: [hydra/posframe] Waiting for MELPA package
    ;;       https://github.com/Ladicle/hydra-posframe/issues/3
    (use-package hydra-posframe
      :straight (:host github :repo "Ladicle/hydra-posframe")
      :hook (after-init . hydra-posframe-mode)
      :custom
      (hydra-posframe-border-width 1)
      (hydra-posframe-parameters '((left-fringe . 8) (right-fringe . 8))))
    #+end_src

*** ace-window
    Jump around Emacs windows & frames using character prefixes.
    I use this constantly - it even works across multiple frames.
    Also added a hydra borrowed from [[https://oremacs.com/2015/01/29/more-hydra-goodness/][here]] for some really convenient movement/manipulation!
    #+begin_src emacs-lisp
    (use-package ace-window
      :bind ("M-o" . hydra-window/body)
      :custom
      (aw-dispatch-always t)
      (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
      :config
      (defhydra hydra-window (:color blue)
        "window"
        ("h" windmove-left "left")
        ("j" windmove-down "down")
        ("k" windmove-up "up")
        ("l" windmove-right "right")
        ("a" ace-window "ace")
        ("s" (lambda () (interactive) (ace-window 4)) "swap")
        ("d" (lambda () (interactive) (ace-window 16)) "delete")
        ("q" nil "Quit")))
    #+end_src

*** Smartparens
    Brilliant automatic balancing of pairs. Makes for a really nice experience when typing in any language - programming or not.
    Just check out some of the gifs in the project's README.
    #+BEGIN_SRC emacs-lisp
    (use-package smartparens
      :hook (after-init . smartparens-global-strict-mode))
    #+END_SRC

