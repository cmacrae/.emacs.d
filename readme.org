* About
  This is my literate configuration for [[https://www.gnu.org/software/emacs/][Emacs]].
  This document includes a collection of configuration snippets to express how I personally like to use Emacs, each accompanied by some reasoning.
  I think it's important to include reasoning for each part so I can understand /why/ I use it. Plus the added benefit of others being able to peruse and borrow parts, just as I have from others.

  The combination of literacy and functionality is achieved using the amazing [[http://orgmode.org/][org-mode]], with [[http://orgmode.org/worg/org-contrib/babel/][org-babel]].

  Throughout this document, you'll notice heavy use of the brilliant [[https://github.com/jwiegley/use-package][use-package]].
  For anyone who hasn't tried out ~use-package~; I emplore you to do so - it truly makes managing your configuration an absolute joy.

* Configuration
** General
*** Global =:ensure= for use-package statements
    =use-package= has an =:ensure= keyword which dictates whether packages are installed or not.
    As most of my =use-package= configurations are for external packages, I set this to always ensure.
    Then, in cases where I don't want this to be true, I simply set =:ensure nil=
    #+BEGIN_SRC emacs-lisp
    (setq use-package-always-ensure t)
    #+END_SRC

*** A few Darwin specific configurations
    To make Emacs play a little nicer with window management, enable menu-bar-mode.
    Also, set the frame's dimensions based on pixels - this makes Emacs play nicer with tiling
    window managers, where no title bar is displayed.
    #+BEGIN_SRC emacs-lisp
    (cond
      ((string-equal system-type "darwin")
        (setq mac-option-modifier 'meta)
        (menu-bar-mode t)
        (setq frame-resize-pixelwise t)))
    #+END_SRC

** Meta Configurations
   This section includes the use of any "meta" collection of Emacs configurations provided by others.
   I'm using [[https://github.com/rougier/nano-emacs/issues/37][rougier/nano-emacs]] as a base. The configuration is shaped around principles that I agree with.
   #+BEGIN_SRC emacs-lisp
   (use-package nano-emacs
     :straight (:host github :repo "rougier/nano-emacs")
     :init
     (require 'nano-base-colors)
     (require 'nano-colors)
     (require 'nano-faces)
     (require 'nano-theme)
     (require 'nano-theme-dark)
     (require 'nano-theme-light)
     (require 'nano-modeline)
     ;; (require 'nano-writer)
     ;; Seems there's a bug with this: Wrong type argument: char-table-p, nil
     ;; Returned from this in nano-layout.el
     ;;
     ;; (defface fallback '((t :family "Fira Code"
     ;;                        :inherit 'nano-face-faded)) "Fallback")
     ;; (set-display-table-slot standard-display-table 'truncation
     ;;                         (make-glyph-code ?… 'fallback))
     ;; (set-display-table-slot standard-display-table 'wrap
     ;;                          (make-glyph-code ?↩ 'fallback))
     ;; (require 'nano-layout)

     :hook
     (after-init . nano-faces)
     (after-init . nano-theme))
   #+END_SRC

** Packages
*** Ivy|Counsel|Swiper
    Absolutely brilliant interactive interface and completion frameworks.
    These packages improve the Emacs experience so much.
    As you can see from the =:bind= sections, I use these to replace some of the most used actions.

**** Ivy
    - Suppress count visibility for =ivy-read=
    - Set initial chars for certain inputs
    - Display the candidate menu at the current point position with =ivy-posframe=

    #+BEGIN_SRC emacs-lisp
    (use-package ivy
      :hook (after-init . ivy-mode)
      :bind
      ("C-s"     . swiper)
      ("M-x"     . counsel-M-x)
      ("C-x C-f" . counsel-find-file)
      
      :custom
      (ivy-height 4)
      (ivy-count-format "")
      (ivy-use-virtual-buffers t)
      (enable-recursive-minibuffers t)
      (ivy-initial-inputs-alist: '((counsel-minor            . "^+" )
                                   (counsel-package          . "^+" )
                                   (counsel-org-capture      . "^"  )
                                   (counsel-M-x              . "^"  )
                                   (counsel-describe-symbol  . "^"  )
                                   (org-refile               . ""   ) 
                                   (org-agenda-refile        . ""   )
                                   (org-capture-refile       . ""   )
                                   (Man-completion-table     . "^"  )
                                   (woman                    . "^"  ))))

    (use-package ivy-posframe
      :after ivy
      :hook (ivy-mode . ivy-posframe-mode)
      :custom
      (ivy-posframe-border-width 1)
      (ivy-posframe-parameters '((left-fringe . 8) (right-fringe . 8))
                                (swiper . nil)))
   #+END_SRC

**** Counsel
     - Set a prettier candidate delimiter for killring
     - Bind common functions
     - Bind common org functions
     - Ensure `smex` is installed for better candidate matching
    #+begin_src emacs-lisp
    (use-package counsel
      :custom
      (counsel-yank-pop-separator (concat "\n\n"
          (concat (apply 'concat (make-list 50 "---")) "\n")))
	
      :bind
      (("M-y"   . counsel-yank-pop)
       ("C-h f" . counsel-describe-function)
       ("C-h v" . counsel-describe-variable)

       :map org-mode-map
       ("C-c  C-j" . counsel-org-goto)
       ("C-c  C-q" . counsel-org-tag))

      :config
      (use-package smex :ensure t))
    #+end_src

*** Evil
    Vim emulation in Emacs. Because: yes, you can have the best of both worlds!

    Below you'll find various extensions to my Evil layer that generally improve the quality of life.
    #+BEGIN_SRC emacs-lisp
    (use-package evil
      :init (setq evil-want-C-u-scroll t)
      :hook (after-init . evil-mode))
    #+END_SRC

*** Projectile
    Project management based on version control repositories.
    Absolutely essential package for me. This makes hopping around and between various projects really easy.
    Not only that, but it allows project-wide actions. Like killing all buffers for a project, performing a project-wide find-and-replace, or a grep, etc.

    Some configuration I use:
    - Setting the completion system to =ivy=
    - Further integration of Counsel with Projectile than what's provided natively
    #+BEGIN_SRC emacs-lisp
    (use-package projectile
      :hook
      (after-init . projectile-global-mode)
      :custom
      (projectile-completion-system 'ivy))

    (use-package counsel-projectile
      :after projectile
      :hook
      (projectile-global-mode . counsel-projectile-mode)
      :bind
      ("C-c p s r" . counsel-projectile-rg))
    #+END_SRC

*** Magit
    The one true Git porcelain!
    Truely a joy to use - it surfaces the power of Git in such a fluent manner.
    Anyone using Git and Emacs *needs* Magit in their life!
    #+BEGIN_SRC emacs-lisp
    (use-package magit
      :bind ("C-c m" . magit-status))
    #+END_SRC

*** Flycheck
    Have Flycheck turned on for everything - checking stuff is always good!
    And for convenience, add a ~posframe~.
    #+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :hook (after-init . global-flycheck-mode))
 
    (use-package flycheck-posframe
      :after flycheck
      :hook (flycheck-mode . flycheck-posframe-mode))
    #+END_SRC

*** Company
   Slick auto-complete framework
   #+BEGIN_SRC emacs-lisp
   (use-package company
     :hook (after-init . global-company-mode))
   #+END_SRC
*** hydra
    Great package to tie tangible actions together into convenient keybinding landscapes.
    Here, you'll find some "general" hydras - other hydras that are centric around packages will be found with that package's configuration.
  
    General hydras:
    - Zoom: increase/decrease current buffer text size
    - Transpose: transpose various constructs of text
    - Toggle mode: turn frequently "toggled" modes on and off
  
    Enhancement packages:
    - =hydra-posframe=: use =posframe= to display hydra buffers at custom positions
    #+begin_src emacs-lisp
    (use-package hydra
      :bind
      ("C-c z" . hydra-zoom/body)
      ("C-c T" . hydra-transpose/body)
      ("C-c M" . hydra-toggle-mode/body)
  
      :config
      ;; Zoom
      (defhydra hydra-zoom ()
        "Zoom"
        ("i" text-scale-increase "In")
        ("o" text-scale-decrease "Out")
        ("q" nil "Quit" :color blue))
  
      ;; Transpose
      (defhydra hydra-transpose (:color red)
        "Transpose"
        ("c" transpose-chars "Characters")
        ("w" transpose-words "Words")
        ("l" transpose-lines "Lines")
        ("s" transpose-sentences "Sentences")
        ("p" transpose-paragraphs "Paragraphs")
        ("q" nil "Quit" :color blue)))

    ;; TODO: [hydra/posframe] Waiting for MELPA package
    ;;       https://github.com/Ladicle/hydra-posframe/issues/3
    (use-package hydra-posframe
      :straight (:host github :repo "Ladicle/hydra-posframe")
      :hook (after-init . hydra-posframe-mode)
      :custom
      (hydra-posframe-border-width 1)
      (hydra-posframe-parameters '((left-fringe . 8) (right-fringe . 8))))
    #+end_src

*** ace-window
    Jump around Emacs windows & frames using character prefixes.
    I use this constantly - it even works across multiple frames.
    Also added a hydra borrowed from [[https://oremacs.com/2015/01/29/more-hydra-goodness/][here]] for some really convenient movement/manipulation!
    #+begin_src emacs-lisp
    (use-package ace-window
      :bind ("M-o" . hydra-window/body)
      :custom
      (aw-dispatch-always t)
      (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
      :config
      (defhydra hydra-window (:color blue)
        "window"
        ("h" windmove-left "left")
        ("j" windmove-down "down")
        ("k" windmove-up "up")
        ("l" windmove-right "right")
        ("a" ace-window "ace")
        ("s" (lambda () (interactive) (ace-window 4)) "swap")
        ("d" (lambda () (interactive) (ace-window 16)) "delete")
        ("q" nil "Quit")))
    #+end_src

*** Smartparens
    Brilliant automatic balancing of pairs. Makes for a really nice experience when typing in any language - programming or not.
    Just check out some of the gifs in the project's README.
    #+BEGIN_SRC emacs-lisp
    (use-package smartparens
      :hook (after-init . smartparens-global-strict-mode))
    #+END_SRC

